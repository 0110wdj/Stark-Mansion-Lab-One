## 61 介绍下如何实现 token 加密

> 服务端在生成 token 时，加入少量的用户信息，比如用户的 id。服务端接收到 token 之后，可以解析出这些数据，从而将 token 和用户关联了起来。

> 需要一个 secret（随机数）
> 后端利用 secret 和加密算法(如：HMAC-SHA256)对 payload(如账号密码)生成一个字符串(token)，返回前端
> 前端每次 request 在 header 中带上 token
> 后端用同样的算法解密

## 62 redux 为什么要把 reducer 设计成纯函数

redux 的设计思想就是不产生副作用，数据更改的状态可回溯，所以 redux 中处处都是纯函数

redux 三大原则

- 单一数据流
  整个应用 state 都被储存在一个 store 里面 构成一个 Object tree
- State 是只读的
  唯一改变 state 的方法就是触发 action, action 是一个用于描述已发生事件的普通对象
- 使用纯函数来执行修改
  为了描述 action 如何改变 state tree， 你需要编写 reducers
  把 reducer 设计成纯函数，可以实现时间旅行，记录/回放或者热加载

store 里的 state 是一个引用类型，多个组件都可能共享这个 state，如果允许直接在组件中修改这个 state，由于组件间千丝万缕的关系，复杂度会变得很高，定位问题会变得异常困难，因为很难搞清楚到底是哪个组件“搞坏”了数据，而采用纯函数就没有这样的副作用。

## 63 如何设计实现无缝轮播

代码千万种，这里主要说一下两种实现思想：

- 每次轮播元素动画执行到末尾的时候迅速让其位置恢复原位，造成视觉上的无缝轮播
- 将轮播元素复制一份，第一个 item 元素轮播执行完后将其删除后添加在整个轮播列表的最后，造成循环轮播

## 64 模拟实现一个 Promise.finally

64.js

## 65 哪个性能更高？

```js
a["b"]["c"]["d"];
a.b.c.d;
```

> 这个题从 AST 角度看就很简单了，两者转换成 AST 前者的的树是含计算的，后者只是 string literal，天然前者会消耗更多的计算成本，时间也更长。

## 66 ES6 代码转成 ES5 代码的实现思路是什么

ES6 转 ES5 分为以下两种情况

- 1.语法转换
  ES6 语法通过 babel 等工具为 ES5 语法，本质是将 ES6 语法转 AST（抽象语法数——对编程语言编写的程序的一种描述）再将 AST 转为 ES5 语法代码；例如：let,const 转换为 var，箭头函数转换为 function 函数声明等
- 2.API 转换
  采用 babel-polyfill 等工具对 ES5 中不存在的 API（包括 Set 等 ES6 中新的数据结构）做修复，例如：Array.prototype.includes Set Map 等在 ES5 中不存在，需要用相应的 ES5 代码实现这些 API

## 67 数组编程题

```
随机生成一个长度为 10 的整数类型的数组，例如 [2, 10, 3, 4, 5, 11, 10, 11, 20]，将其排列成一个新数组，要求新数组形式如下，例如 [[2, 3, 4, 5], [10, 11], [20]]。
```

67.js

## 68 如何解决移动端 Retina 屏 1px 像素问题？

[7 种方法解决移动端 Retina 屏幕 1px 边框问题](https://juejin.cn/post/6844903456717668359)

## 69 如何把一个字符串的大小写取反（大写变小写小写变大写），例如 ’AbC' 变成 'aBc' 。

略

## 70 介绍下 webpack 热更新原理，是如何做到在不刷新浏览器的前提下更新页面的。

Webpack 的热更新通过以下几个关键点实现：

- 监听文件更改，重新编译模块。

- 使用 WebSocket 通知浏览器模块变更。

- 浏览器通过 HMR API 加载更新的模块。

- 保持页面状态不变，避免刷新浏览器。

## 71 实现一个字符串匹配算法，从长度为 n 的字符串 S 中，查找是否存在字符串 T，T 的长度是 m，若存在返回所在位置。

71.js

## 72 为什么普通 for 循环的性能远远高于 forEach 的性能，请解释其中的原因。

不一定。

### 🔍 一览表：`for` vs `forEach`

| 比较维度          | `for` 循环                    | `forEach` 循环                      |
| ----------------- | ----------------------------- | ----------------------------------- |
| **语法类型**      | 语法结构（流程控制）          | 数组方法（函数式）                  |
| **函数调用开销**  | ✅ 无函数调用开销             | ❌ 每次迭代调用一次回调函数         |
| **可中断性**      | ✅ 支持 `break` / `continue`  | ❌ 不支持中断，只能抛异常           |
| **异步兼容性**    | ✅ 可搭配 `await` 串行执行    | ⚠️ 异步回调中 `await` 不起作用      |
| **可读性/简洁性** | ❌ 写法更长、更灵活           | ✅ 简洁易读（尤其适合简单逻辑）     |
| **稀疏数组处理**  | ❌ 会访问所有索引（包括空项） | ✅ 自动跳过稀疏项                   |
| **链式调用能力**  | ❌ 无法链式调用               | ✅ 可与 `map` / `filter` 等组合使用 |
| **性能表现**      | ✅ 更快（特别是大数组）       | ❌ 函数式开销稍大                   |
| **引擎优化**      | ✅ 优化更成熟                 | ⚠️ 抽象程度高，优化有限             |
| **语义清晰性**    | ⚠️ 灵活但易写错               | ✅ 回调封装逻辑更清晰               |

### ✅ 推荐使用场景总结：

| 使用场景描述                              | 推荐用法                | 理由说明                   |
| ----------------------------------------- | ----------------------- | -------------------------- |
| 遍历大数组，追求性能                      | `for`                   | 避免回调函数开销，性能更优 |
| 需要中途退出循环（如找到目标值后）        | `for`                   | 支持 `break` / `return`    |
| 逻辑简单、偏向声明式风格                  | `forEach`               | 简洁可读                   |
| 遍历稀疏数组，跳过空项                    | `forEach`               | 自动跳过空值               |
| 与 `map/filter/reduce` 等链式函数组合使用 | `forEach`               | 风格一致、表达清晰         |
| 异步任务需并发处理（如下载多个文件）      | `forEach + Promise.all` | 可并发执行所有任务         |
| 异步任务需严格串行执行（逐个处理）        | `for + await`           | 逐步等待完成，保证顺序     |
| 数组可能在遍历中被修改（如添加元素）      | `forEach`               | 避免死循环，行为更稳定     |
