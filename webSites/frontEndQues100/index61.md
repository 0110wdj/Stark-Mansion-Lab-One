## 61 介绍下如何实现 token 加密

> 服务端在生成 token 时，加入少量的用户信息，比如用户的 id。服务端接收到 token 之后，可以解析出这些数据，从而将 token 和用户关联了起来。

> 需要一个 secret（随机数）
> 后端利用 secret 和加密算法(如：HMAC-SHA256)对 payload(如账号密码)生成一个字符串(token)，返回前端
> 前端每次 request 在 header 中带上 token
> 后端用同样的算法解密

## 62 redux 为什么要把 reducer 设计成纯函数

redux 的设计思想就是不产生副作用，数据更改的状态可回溯，所以 redux 中处处都是纯函数

redux 三大原则

- 单一数据流
  整个应用 state 都被储存在一个 store 里面 构成一个 Object tree
- State 是只读的
  唯一改变 state 的方法就是触发 action, action 是一个用于描述已发生事件的普通对象
- 使用纯函数来执行修改
  为了描述 action 如何改变 state tree， 你需要编写 reducers
  把 reducer 设计成纯函数，可以实现时间旅行，记录/回放或者热加载

store 里的 state 是一个引用类型，多个组件都可能共享这个 state，如果允许直接在组件中修改这个 state，由于组件间千丝万缕的关系，复杂度会变得很高，定位问题会变得异常困难，因为很难搞清楚到底是哪个组件“搞坏”了数据，而采用纯函数就没有这样的副作用。

## 63 如何设计实现无缝轮播

代码千万种，这里主要说一下两种实现思想：

- 每次轮播元素动画执行到末尾的时候迅速让其位置恢复原位，造成视觉上的无缝轮播
- 将轮播元素复制一份，第一个 item 元素轮播执行完后将其删除后添加在整个轮播列表的最后，造成循环轮播

## 64 模拟实现一个 Promise.finally

64.js

## 65 哪个性能更高？

```js
a["b"]["c"]["d"];
a.b.c.d;
```

> 这个题从 AST 角度看就很简单了，两者转换成 AST 前者的的树是含计算的，后者只是 string literal，天然前者会消耗更多的计算成本，时间也更长。

## 66 ES6 代码转成 ES5 代码的实现思路是什么

ES6 转 ES5 分为以下两种情况

- 1.语法转换
  ES6 语法通过 babel 等工具为 ES5 语法，本质是将 ES6 语法转 AST（抽象语法数——对编程语言编写的程序的一种描述）再将 AST 转为 ES5 语法代码；例如：let,const 转换为 var，箭头函数转换为 function 函数声明等
- 2.API 转换
  采用 babel-polyfill 等工具对 ES5 中不存在的 API（包括 Set 等 ES6 中新的数据结构）做修复，例如：Array.prototype.includes Set Map 等在 ES5 中不存在，需要用相应的 ES5 代码实现这些 API
