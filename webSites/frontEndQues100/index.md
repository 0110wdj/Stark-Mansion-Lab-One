### 前言

本文相当于练习笔记。[原文链接](https://juejin.cn/post/6844903885488783374)

### 正文

#### 1 写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？

snofly：

> 它们的 dom 更新机制都是基于“元素替换”来实现的，那么找到最小单位的替换元素可以大幅度减少无效的 dom 操作。在定位需要替换的元素时，react 中是根据状态值的变化来找到相关的组件 —— 也就是将要替换到页面上的元素。如果设置了 key，react 可以更准确的定位到该组件内部的变化细节出现的子元素，那么 dom 替换操作是可以只替换这个子元素。

chatgpt:

> 在 React 或 Vue 中，key 是列表中每个元素的唯一标识，用于帮助框架高效地追踪和管理 DOM 元素的更新。其核心作用有以下两点：
> 优化性能：通过 key，框架能快速识别元素的变化（新增、删除或移动），避免不必要的重新渲染。
> 确保正确性：key 确保状态和 DOM 的绑定关系正确，防止因为元素复用导致的状态错乱或动画异常。

原文参考：

> key 是给每一个 vnode 的唯一 id,可以依靠 key,更准确, 更快的拿到 oldVnode 中对应的 vnode 节点。

> vue 和 react 都是采用 diff 算法来对比新旧虚拟节点，从而更新节点。在 vue 的 diff 函数中（建议先了解一下 diff 算法过程）。
> 在交叉对比中，当新节点跟旧节点头尾交叉对比没有结果时，会根据新节点的 key 去对比旧节点数组中的 key，从而找到相应旧节点（这里对应的是一个 key => index 的 map 映射）。如果没找到就认为是一个新增节点。而如果没有 key，那么就会采用遍历查找的方式去找到对应的旧节点。一种一个 map 映射，另一种是遍历查找。相比而言。map 映射的速度更快。

> 我的理解是，vue 和 react 虽然都采用了 diff 算法。 但是 react 本身的设计和 vue 的设计是截然不同的， vue 采用了更加细粒度的更新组件的方式，即给每一个属性绑定监听， 而 react 是采用自顶而下的更新策略，每次小的改动都会生成一个全新的 vdom。
> 总结， 更确切的说应该是 diff 算法在你的复杂的列表稳定的时候能够明显提高性能，因为节点可以重用。
> 但是对于列表频繁更新的场景， 节点不能重用，但是 diff 可以省略一部分逻辑，因此性能也会更好。
> 但是两者的性能优化不在同一个纬度，一个是 创建和更新节点（我称之为渲染器）的优化，
> 一个是 DOM diff 算法（我称之为核心引擎）的优化

#### 2 ['1', '2', '3'].map(parseInt) what & why ?

原文参考:

> 第一眼看到这个题目的时候，脑海跳出的答案是 [1, 2, 3]，但是真正的答案是[1, NaN, NaN]。

> map 函数的第一个参数 callback：
> var new_array = arr.map(function callback(currentValue[, index[, array]]) { // Return element for new_array }[, thisArg])
>
> 而 parseInt 则是用来解析字符串的，使字符串成为指定基数的整数。
> parseInt(string, radix) 接收两个参数，第一个表示被处理的值（字符串），第二个表示为解析时的基数。
>
> parseInt('1', 0) //radix 为 0 时，且 string 参数不以“0x”和“0”开头时，按照 10 为基数处理。这个时候返回 1
> parseInt('2', 1) //基数为 1（1 进制）表示的数中，最大值小于 2，所以无法解析，返回 NaN
> parseInt('3', 2) //基数为 2（2 进制）表示的数中，最大值小于 3，所以无法解析，返回 NaN

补充：

> parseInt 第二个参数需要的范围是 2~36 之间，如果小于 2 或者大于 36，则 parseInt() 将返回 NaN。
> 所以 parseInt('0',1) 和 parseInt('1',37) 都是 NaN。

### 3 什么是防抖和节流？有什么区别？如何实现？

snofly:
防抖是指在