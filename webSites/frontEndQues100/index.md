### 前言

本文相当于练习笔记。[原文链接](https://juejin.cn/post/6844903885488783374)

### 正文

#### 01 写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？

snofly：

> 它们的 dom 更新机制都是基于“元素替换”来实现的，那么找到最小单位的替换元素可以大幅度减少无效的 dom 操作。在定位需要替换的元素时，react 中是根据状态值的变化来找到相关的组件 —— 也就是将要替换到页面上的元素。如果设置了 key，react 可以更准确的定位到该组件内部的变化细节出现的子元素，那么 dom 替换操作是可以只替换这个子元素。

chatgpt:

> 在 React 或 Vue 中，key 是列表中每个元素的唯一标识，用于帮助框架高效地追踪和管理 DOM 元素的更新。其核心作用有以下两点：
> 优化性能：通过 key，框架能快速识别元素的变化（新增、删除或移动），避免不必要的重新渲染。
> 确保正确性：key 确保状态和 DOM 的绑定关系正确，防止因为元素复用导致的状态错乱或动画异常。

原文参考：

> key 是给每一个 vnode 的唯一 id,可以依靠 key,更准确, 更快的拿到 oldVnode 中对应的 vnode 节点。

> vue 和 react 都是采用 diff 算法来对比新旧虚拟节点，从而更新节点。在 vue 的 diff 函数中（建议先了解一下 diff 算法过程）。
> 在交叉对比中，当新节点跟旧节点头尾交叉对比没有结果时，会根据新节点的 key 去对比旧节点数组中的 key，从而找到相应旧节点（这里对应的是一个 key => index 的 map 映射）。如果没找到就认为是一个新增节点。而如果没有 key，那么就会采用遍历查找的方式去找到对应的旧节点。一种一个 map 映射，另一种是遍历查找。相比而言。map 映射的速度更快。

> 我的理解是，vue 和 react 虽然都采用了 diff 算法。 但是 react 本身的设计和 vue 的设计是截然不同的， vue 采用了更加细粒度的更新组件的方式，即给每一个属性绑定监听， 而 react 是采用自顶而下的更新策略，每次小的改动都会生成一个全新的 vdom。
> 总结， 更确切的说应该是 diff 算法在你的复杂的列表稳定的时候能够明显提高性能，因为节点可以重用。
> 但是对于列表频繁更新的场景， 节点不能重用，但是 diff 可以省略一部分逻辑，因此性能也会更好。
> 但是两者的性能优化不在同一个纬度，一个是 创建和更新节点（我称之为渲染器）的优化，
> 一个是 DOM diff 算法（我称之为核心引擎）的优化

#### 02 ['1', '2', '3'].map(parseInt) what & why ?

原文参考:

> 第一眼看到这个题目的时候，脑海跳出的答案是 [1, 2, 3]，但是真正的答案是[1, NaN, NaN]。

> map 函数的第一个参数 callback：
> var new_array = arr.map(function callback(currentValue[, index[, array]]) { // Return element for new_array }[, thisArg])
>
> 而 parseInt 则是用来解析字符串的，使字符串成为指定基数的整数。
> parseInt(string, radix) 接收两个参数，第一个表示被处理的值（字符串），第二个表示为解析时的基数。
>
> parseInt('1', 0) //radix 为 0 时，且 string 参数不以“0x”和“0”开头时，按照 10 为基数处理。这个时候返回 1
> parseInt('2', 1) //基数为 1（1 进制）表示的数中，最大值小于 2，所以无法解析，返回 NaN
> parseInt('3', 2) //基数为 2（2 进制）表示的数中，最大值小于 3，所以无法解析，返回 NaN

补充：

> parseInt 第二个参数需要的范围是 2~36 之间，如果小于 2 或者大于 36，则 parseInt() 将返回 NaN。
> 所以 parseInt('0',1) 和 parseInt('1',37) 都是 NaN。

### 03 什么是防抖和节流？有什么区别？如何实现？

snofly:

> 防抖是指：忽略中间过程触发的事件，只响应最后一次事件触发。
> 节流是指：间隔性响应事件触发，间隔之间的事件将被忽略。
> 防抖只关注最后一次的状态，也只需要触发一次。
> 节流是减少了触发的频率，仍会触发多次。
> 实现：03.js

原文参考:

> 防抖:触发高频事件后 n 秒内函数只会执行一次，如果 n 秒内高频事件再次被触发，则重新计算时间
> 节流:高频事件触发，但在 n 秒内只会执行一次，所以节流会稀释函数的执行频率

补充：

> 注意：高阶函数中的回调函数执行，需要绑定一下 this。

### 04 介绍下 Set、Map、WeakSet 和 WeakMap 的区别？

snofly:

> Set 模拟了数学中的集合，具有无序性、唯一性。Map 基于 hash 实现，具有 Ο(1) 的读取耗时。WeakSet,WeakMap 对象的引用是不长时间保留的，更容易被 GC 处理。

原文参考：

```
Set

- 成员唯一、无序且不重复
- [value, value]，键值与键名是一致的（或者说只有键值，没有键名）
- 可以遍历，方法有：add、delete、has

weakSet

- 成员都是对象
- 成员都是弱引用，可以被垃圾回收机制回收，可以用来保存DOM节点，不容易造成内存泄漏
- 不能遍历，方法有add、delete、has

Map

- 本质上是键值对的集合，类似集合
- 可以遍历，方法很多可以跟各种数据格式转换

weakMap

- 只接受对象作为键名（null除外），不接受其他类型的值作为键名
- 键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的
- 不能遍历，方法有get、set、has、delete

```

### 05 介绍下深度优先遍历和广度优先遍历，如何实现？

snofly:

> 深度优先遍历，一直访问到叶子节点，才会访问同层级的节点；广度优先遍历，先访问完成同层级的节点，才会访问下一层的节点。深度优先遍历用递归访问；广度优先遍历暂存下一层级的节点。

原文参考：

> 深度优先遍历 DFS 与树的先序遍历比较类似。
> 假设初始状态是图中所有顶点均未被访问，则从某个顶点 v 出发，首先访问该顶点然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和 v 有路径相通的顶点都被访问到。若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。

> 广度优先遍历 BFS
> 从图中某顶点 v 出发，在访问了 v 之后依次访问 v 的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。 如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。

### 06 请分别用深度优先思想和广度优先思想实现一个拷贝函数？

snofly:

> 实现：06_source.js

> 注意处理对象的循环引用，函数的复制

### 07 ES5/ES6 的继承除了写法以外还有什么区别？

chatGPT:

> ES5 和 ES6 的继承除了语法上的差异外，主要还在于以下几个方面的区别：
>
> - 1、构造函数的行为：
>   - ES5：继承通过 call 或 apply 在子类构造函数中调用父类构造函数，通常需要手动设置 this。
>   - ES6：ES6 引入了 class 和 extends 语法，继承时在子类构造函数中使用 super() 调用父类构造函数，自动绑定 this。

> - 2、原型链的设置：
>   - ES5：手动设置子类的原型链，通常通过 Object.create() 或 new Parent() 来实现。
>   - ES6：通过 extends 关键字自动设置了原型链。

> - 3、super 的使用：
>   - ES5：没有 super 关键字，父类的方法或构造函数调用需要直接通过 call 或 apply。
>   - ES6：super 关键字不仅用于调用父类构造函数，还可以用来调用父类的方法。

> - 4、instanceof 的判断：
>   - ES5：继承关系是通过原型链来实现的，通过 instanceof 判断时会检查 \_\_proto\_\_。
>   - ES6：继承关系通过 class 和 extends 显式声明，所以使用 instanceof 判断时也基于类的原型链，保持一致性。

> - 5、类的静态方法：
>   - ES5：没有类静态方法的概念，静态方法是通过在构造函数本身上定义的。
>   - ES6：可以在类上直接定义静态方法，static 关键字用来声明静态方法。

> 总结来说，ES6 的继承语法更加简洁、直观，同时解决了一些 ES5 中需要手动处理的问题，使继承机制更加规范化和易用。

### 08 setTimeout、Promise、Async/Await 的区别？

snofly:

> 都会创建任务，但是任务队列的优先级不同。setTimeout 创建宏任务，优先级最低；Promise、Async/Await 创建微任务，优先级较高。

> Promise 是立即执行函数，Async 函数返回值是 Promise

test code : 08.js

### 09 Async/Await 如何通过同步的方式实现异步

snofy:

> async 函数返回值被 Promise 包裹，保证同步代码的非阻塞执行。
> await 某个 async 函数时，其后的代码暂停执行，实际上是变成了异步任务代码，作为一个微任务推入任务队列中。
> 等到该 async 函数变成完成状态，再从任务队列中取出到调用栈中。

### 10 请写出下面代码的运行结果

snofly:

> 代码和分析 code: 10.js

### 11 手写

已知如下数组：
var arr = [ [1, 2, 2], [3, 4, 5, 5], [6, 7, 8, 9, [11, 12, [12, 13[ 14 ] ] ] ], 10];
编写一个程序将数组扁平化去并除其中重复部分数据，最终得到一个升序且不重复的数组

code: 11.js

### 12 JS 异步解决方案的发展历程以及优缺点

snfly:

> 对于 IO 等异步场景，最早是基于回调函数来处理 IO 结束后的逻辑。
> 之后，引入 Promise 方案，来记录函数的 pedding 或 resolve 或 reject 状态，更好的编写回调函数。
> 同时，基于 generator 函数、yeild 或 next 中断函数的机制，将回调函数的代码放在 generator 函数内部。
> 最成熟的现代化方案是 async\await 机制，将回调函数放在事件循环的微任务队列中，结合 Promisw 来控制调用时机。
> 变化趋势是代码的整洁、易读性的提高；理解难度会提高一点点。

参考信息：

> 1. 回调函数（callback）
>    缺点：回调地狱，不能用 try catch 捕获错误，不能 return
>    回调地狱的根本问题在于：
>    缺乏顺序性： 回调地狱导致的调试困难，和大脑的思维方式不符
>    嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身，即（控制反转）
>    嵌套函数过多的多话，很难处理错误
>    优点：解决了同步的问题（只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。）

> 2. Promise
>    Promise 就是为了解决 callback 的问题而产生的。
>    Promise 实现了链式调用，也就是说每次 then 后返回的都是一个全新 Promise，如果我们在 then 中 return ，return 的结果会被 Promise.resolve() 包装。
>    优点：解决了回调地狱的问题
>    缺点：无法取消 Promise ，错误需要通过回调函数来捕获

> 3. Generator
>    特点：可以控制函数的执行，可以配合 co 函数库使用

> 4. Async/await
>    async、await 是异步的终极解决方案
>    优点是：代码清晰，不用像 Promise 写一大堆 then 链，处理了回调地狱的问题
>    缺点：await 将异步代码改造成同步代码，如果多个异步操作没有依赖性而使用 await 会导致性能上的降低。

### 13 Promise 构造函数是同步执行还是异步执行，那么 then 方法呢？

snofly:

> Promise 构造函数是同步执行,then 方法是异步执行.

### 14 如何实现一个 new

参考信息：14.js

### 15 简单讲解一下 http2 的多路复用

参考信息：

> HTTP2 采用二进制格式传输，取代了 HTTP1.x 的文本格式，二进制格式解析更高效。
>
> 多路复用代替了 HTTP1.x 的序列和阻塞机制，所有的相同域名请求都通过同一个 TCP 连接并发完成。
>
> 在 HTTP1.x 中，并发多个请求需要多个 TCP 连接，浏览器为了控制资源会有 6-8 个 TCP 连接都限制。
>
> HTTP2 中
>
> - 同域名下所有通信都在单个连接上完成，消除了因多个 TCP 连接而带来的延时和内存消耗。
> - 单个连接上可以并行交错的请求和响应，之间互不干扰。

参考信息二：

> http/1.0：如需要发送多个请求必须创建多个 TCP 连接，并且浏览器对于单域名请求有数量限制（一般 6 个），其连接无法被复用
>
> http/1.1：引入流水线（Pipelining）技术，但先天 FIFO（先进先出）机制导致当前请求的执行依赖于上一个请求执行的完成，容易引起报头阻塞，并没有从根本上解决问题
>
> http/2：重新定义底层 http 语义映射，允许同一个连接上使用请求和响应双向数据流。同一域名只需占用一个 TCP 连接，通过数据流（Stream）以帧为基本协议单位，从根本上解决了问题，避免了因频繁创建连接产生的延迟，减少了内存消耗，提升了使用性能
>
> 资料：《koa 与 nodejs 开发实战》 http 篇

### 16 谈谈你对 TCP 三次握手和四次挥手的理解

snofly：

> 确保链接两端都处于正常工作的状态，或者都完成了退出。

参考信息：

> 三次握手之所以是三次是保证 client 和 server 均让对方知道自己的接收和发送能力没问题而保证的最小次数。
>
> 第一次 client => server 只能 server 判断出 client 具备发送能力
> 第二次 server => client client 就可以判断出 server 具备发送和接受能力。此时 client 还需让 server 知道自己接收能力没问题于是就有了第三次
> 第三次 client => server 双方均保证了自己的接收和发送能力没有问题
>
> 其中，为了保证后续的握手是为了应答上一个握手，每次握手都会带一个标识 seq，后续的 ACK 都会对这个 seq 进行加一来进行确认。

> 四次握手就是中间多了一层 等待服务器再一次响应回复相关数据的过程

### 17 A、B 机器正常连接后，B 机器突然重启，问 A 此时处于 TCP 什么状态

如果 A 与 B 建立了正常连接后，从未相互发过数据，这个时候 B 突然机器重启，问 A 此时处于 TCP 什么状态？如何消除服务器程序中的这个状态？（超纲题，了解即可）

GPT:

> 当 B 重启后，A 可能处于 ESTABLISHED 状态，等待数据交换或重试。可以通过超时机制、Keep-Alive 选项或其他错误检测机制来消除连接问题，确保程序能够恢复。

### 18 在 React 中 setState 什么时候是同步的，什么时候是异步的？

参考信息：

> 在 React 中，如果是由 React 引发的事件处理（比如通过 onClick 引发的事件处理），调用 setState 不会同步更新 this.state，除此之外的 setState 调用会同步执行 this.state 。所谓“除此之外”，指的是绕过 React 通过 addEventListener 直接添加的事件处理函数，还有通过 setTimeout/setInterval 产生的异步调用。
>
> 原因： 在 React 的 setState 函数实现中，会根据一个变量 isBatchingUpdates 判断是直接更新 this.state 还是放到队列中回头再说，而 isBatchingUpdates 默认是 false，也就表示 setState 会同步更新 this.state，但是，有一个函数 batchedUpdates，这个函数会把 isBatchingUpdates 修改为 true，而当 React 在调用事件处理函数之前就会调用这个 batchedUpdates，造成的后果，就是由 React 控制的事件处理过程 setState 不会同步更新 this.state。
>
> 注意： setState 的“异步”并不是说内部由异步代码实现，其实本身执行的过程和代码都是同步的，只是合成事件和钩子函数的调用顺序在更新之前，导致在合成事件和钩子函数中没法立马拿到更新后的值，形式了所谓的“异步”，当然可以通过第二个参数 setState(partialState, callback) 中的 callback 拿到更新后的结果。

### 19 React setState 笔试题，下面的代码输出什么？

```jsx
class Example extends React.Component {
  constructor() {
    super();
    this.state = {
      val: 0,
    };
  }

  componentDidMount() {
    this.setState({ val: this.state.val + 1 });
    console.log(this.state.val); // 第 1 次 log // 0

    this.setState({ val: this.state.val + 1 });
    console.log(this.state.val); // 第 2 次 log // 0

    setTimeout(() => {
      this.setState({ val: this.state.val + 1 });
      console.log(this.state.val); // 第 3 次 log // 2

      this.setState({ val: this.state.val + 1 });
      console.log(this.state.val); // 第 4 次 log // 3
    }, 0);
  }

  render() {
    return null;
  }
}
```
