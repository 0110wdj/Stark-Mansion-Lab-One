### 前言

本文相当于练习笔记。[原文链接](https://juejin.cn/post/6844903885488783374)

### 正文

#### 01 写 React / Vue 项目时为什么要在列表组件中写 key，其作用是什么？

snofly：

> 它们的 dom 更新机制都是基于“元素替换”来实现的，那么找到最小单位的替换元素可以大幅度减少无效的 dom 操作。在定位需要替换的元素时，react 中是根据状态值的变化来找到相关的组件 —— 也就是将要替换到页面上的元素。如果设置了 key，react 可以更准确的定位到该组件内部的变化细节出现的子元素，那么 dom 替换操作是可以只替换这个子元素。

chatgpt:

> 在 React 或 Vue 中，key 是列表中每个元素的唯一标识，用于帮助框架高效地追踪和管理 DOM 元素的更新。其核心作用有以下两点：
> 优化性能：通过 key，框架能快速识别元素的变化（新增、删除或移动），避免不必要的重新渲染。
> 确保正确性：key 确保状态和 DOM 的绑定关系正确，防止因为元素复用导致的状态错乱或动画异常。

原文参考：

> key 是给每一个 vnode 的唯一 id,可以依靠 key,更准确, 更快的拿到 oldVnode 中对应的 vnode 节点。

> vue 和 react 都是采用 diff 算法来对比新旧虚拟节点，从而更新节点。在 vue 的 diff 函数中（建议先了解一下 diff 算法过程）。
> 在交叉对比中，当新节点跟旧节点头尾交叉对比没有结果时，会根据新节点的 key 去对比旧节点数组中的 key，从而找到相应旧节点（这里对应的是一个 key => index 的 map 映射）。如果没找到就认为是一个新增节点。而如果没有 key，那么就会采用遍历查找的方式去找到对应的旧节点。一种一个 map 映射，另一种是遍历查找。相比而言。map 映射的速度更快。

> 我的理解是，vue 和 react 虽然都采用了 diff 算法。 但是 react 本身的设计和 vue 的设计是截然不同的， vue 采用了更加细粒度的更新组件的方式，即给每一个属性绑定监听， 而 react 是采用自顶而下的更新策略，每次小的改动都会生成一个全新的 vdom。
> 总结， 更确切的说应该是 diff 算法在你的复杂的列表稳定的时候能够明显提高性能，因为节点可以重用。
> 但是对于列表频繁更新的场景， 节点不能重用，但是 diff 可以省略一部分逻辑，因此性能也会更好。
> 但是两者的性能优化不在同一个纬度，一个是 创建和更新节点（我称之为渲染器）的优化，
> 一个是 DOM diff 算法（我称之为核心引擎）的优化

#### 02 ['1', '2', '3'].map(parseInt) what & why ?

原文参考:

> 第一眼看到这个题目的时候，脑海跳出的答案是 [1, 2, 3]，但是真正的答案是[1, NaN, NaN]。

> map 函数的第一个参数 callback：
> var new_array = arr.map(function callback(currentValue[, index[, array]]) { // Return element for new_array }[, thisArg])
>
> 而 parseInt 则是用来解析字符串的，使字符串成为指定基数的整数。
> parseInt(string, radix) 接收两个参数，第一个表示被处理的值（字符串），第二个表示为解析时的基数。
>
> parseInt('1', 0) //radix 为 0 时，且 string 参数不以“0x”和“0”开头时，按照 10 为基数处理。这个时候返回 1
> parseInt('2', 1) //基数为 1（1 进制）表示的数中，最大值小于 2，所以无法解析，返回 NaN
> parseInt('3', 2) //基数为 2（2 进制）表示的数中，最大值小于 3，所以无法解析，返回 NaN

补充：

> parseInt 第二个参数需要的范围是 2~36 之间，如果小于 2 或者大于 36，则 parseInt() 将返回 NaN。
> 所以 parseInt('0',1) 和 parseInt('1',37) 都是 NaN。

### 03 什么是防抖和节流？有什么区别？如何实现？

snofly:

> 防抖是指：忽略中间过程触发的事件，只响应最后一次事件触发。
> 节流是指：间隔性响应事件触发，间隔之间的事件将被忽略。
> 防抖只关注最后一次的状态，也只需要触发一次。
> 节流是减少了触发的频率，仍会触发多次。
> 实现：03.js

原文参考:

> 防抖:触发高频事件后 n 秒内函数只会执行一次，如果 n 秒内高频事件再次被触发，则重新计算时间
> 节流:高频事件触发，但在 n 秒内只会执行一次，所以节流会稀释函数的执行频率

补充：

> 注意：高阶函数中的回调函数执行，需要绑定一下 this。

### 04 介绍下 Set、Map、WeakSet 和 WeakMap 的区别？

snofly:

> Set 模拟了数学中的集合，具有无序性、唯一性。Map 基于 hash 实现，具有 Ο(1) 的读取耗时。WeakSet,WeakMap 对象的引用是不长时间保留的，更容易被 GC 处理。

原文参考：

```
Set

- 成员唯一、无序且不重复
- [value, value]，键值与键名是一致的（或者说只有键值，没有键名）
- 可以遍历，方法有：add、delete、has

weakSet

- 成员都是对象
- 成员都是弱引用，可以被垃圾回收机制回收，可以用来保存DOM节点，不容易造成内存泄漏
- 不能遍历，方法有add、delete、has

Map

- 本质上是键值对的集合，类似集合
- 可以遍历，方法很多可以跟各种数据格式转换

weakMap

- 只接受对象作为键名（null除外），不接受其他类型的值作为键名
- 键名是弱引用，键值可以是任意的，键名所指向的对象可以被垃圾回收，此时键名是无效的
- 不能遍历，方法有get、set、has、delete

```

### 05 介绍下深度优先遍历和广度优先遍历，如何实现？

snofly:

> 深度优先遍历，一直访问到叶子节点，才会访问同层级的节点；广度优先遍历，先访问完成同层级的节点，才会访问下一层的节点。深度优先遍历用递归访问；广度优先遍历暂存下一层级的节点。

原文参考：

> 深度优先遍历 DFS 与树的先序遍历比较类似。
> 假设初始状态是图中所有顶点均未被访问，则从某个顶点 v 出发，首先访问该顶点然后依次从它的各个未被访问的邻接点出发深度优先搜索遍历图，直至图中所有和 v 有路径相通的顶点都被访问到。若此时尚有其他顶点未被访问到，则另选一个未被访问的顶点作起始点，重复上述过程，直至图中所有顶点都被访问到为止。

> 广度优先遍历 BFS
> 从图中某顶点 v 出发，在访问了 v 之后依次访问 v 的各个未曾访问过的邻接点，然后分别从这些邻接点出发依次访问它们的邻接点，并使得“先被访问的顶点的邻接点先于后被访问的顶点的邻接点被访问，直至图中所有已被访问的顶点的邻接点都被访问到。 如果此时图中尚有顶点未被访问，则需要另选一个未曾被访问过的顶点作为新的起始点，重复上述过程，直至图中所有顶点都被访问到为止。

### 06 请分别用深度优先思想和广度优先思想实现一个拷贝函数？

snofly:

> 实现：06_source.js

> 注意处理对象的循环引用，函数的复制

### 07 ES5/ES6 的继承除了写法以外还有什么区别？

chatGPT:

> ES5 和 ES6 的继承除了语法上的差异外，主要还在于以下几个方面的区别：
>
> - 1、构造函数的行为：
>   - ES5：继承通过 call 或 apply 在子类构造函数中调用父类构造函数，通常需要手动设置 this。
>   - ES6：ES6 引入了 class 和 extends 语法，继承时在子类构造函数中使用 super() 调用父类构造函数，自动绑定 this。

> - 2、原型链的设置：
>   - ES5：手动设置子类的原型链，通常通过 Object.create() 或 new Parent() 来实现。
>   - ES6：通过 extends 关键字自动设置了原型链。

> - 3、super 的使用：
>   - ES5：没有 super 关键字，父类的方法或构造函数调用需要直接通过 call 或 apply。
>   - ES6：super 关键字不仅用于调用父类构造函数，还可以用来调用父类的方法。

> - 4、instanceof 的判断：
>   - ES5：继承关系是通过原型链来实现的，通过 instanceof 判断时会检查 \_\_proto\_\_。
>   - ES6：继承关系通过 class 和 extends 显式声明，所以使用 instanceof 判断时也基于类的原型链，保持一致性。

> - 5、类的静态方法：
>   - ES5：没有类静态方法的概念，静态方法是通过在构造函数本身上定义的。
>   - ES6：可以在类上直接定义静态方法，static 关键字用来声明静态方法。

> 总结来说，ES6 的继承语法更加简洁、直观，同时解决了一些 ES5 中需要手动处理的问题，使继承机制更加规范化和易用。

### 08 setTimeout、Promise、Async/Await 的区别？

snofly:

> 都会创建任务，但是任务队列的优先级不同。setTimeout 创建宏任务，优先级最低；Promise、Async/Await 创建微任务，优先级较高。

> Promise 是立即执行函数，Async 函数返回值是 Promise

test code : 08.js

### 09 Async/Await 如何通过同步的方式实现异步

snofy:

> async 函数返回值被 Promise 包裹，保证同步代码的非阻塞执行。
> await 某个 async 函数时，其后的代码暂停执行，实际上是变成了异步任务代码，作为一个微任务推入任务队列中。
> 等到该 async 函数变成完成状态，再从任务队列中取出到调用栈中。

### 10 请写出下面代码的运行结果

snofly:

> 代码和分析 code: 10.js
