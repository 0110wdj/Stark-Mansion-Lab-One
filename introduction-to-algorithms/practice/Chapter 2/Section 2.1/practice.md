## 2.2 practice

### 2.1-1 以图 2-2 为模型，说明 INSERTION-SORT 在数组 A=<31，41，59,26，41，58> 上的执行过程。

程序执行过程大概是这样的：

```
41 [ 31, 41, 59, 26, 41, 58 ]
59 [ 31, 41, 59, 26, 41, 58 ]
26 [ 31, 41, 59, 26, 41, 58 ]
26       [ 31, 41, 59, 59, 41, 58 ]
26       [ 31, 41, 41, 59, 41, 58 ]
26       [ 31, 31, 41, 59, 41, 58 ]
41 [ 26, 31, 41, 59, 41, 58 ]
41       [ 26, 31, 41, 59, 59, 58 ]
58 [ 26, 31, 41, 41, 59, 58 ]
58       [ 26, 31, 41, 41, 59, 59 ]
[ 26, 31, 41, 41, 58, 59 ]
```

### 2.1-2 重写过程 INSBRTION-SORT，使之按非升序（而不是非降序）排序。

```js
const insertionSort = (arr, sort = false) => {
  for (let j = 1; j < arr.length; j++) {
    const key = arr[j];
    let i = j - 1;
    while (i >= 0 && (sort ? arr[i] > key : arr[i] < key)) {
      arr[i + 1] = arr[i];
      i = i - 1;
    }
    arr[i + 1] = key;
  }
  return arr;
};
```

### 2.1-3 考虑以下**查找问题**：

- 输入：n 个数的一个序列 A=<a1, a2, ..., an> 和一个值 v。
- 输出：下标 i 使得 v=A[i] 或者当 v 不在 A 中出现时， 为特殊值 NIL。

写出**线性查找**的伪代码，它扫描整个序列来查找 v。使用一个循环不变式来证明你的算法是正确的。确保你的循环不变式满足三条必要的性质。

```
index = NIL
for j = 1 to A.length
  if A[j] == v
    index = j
    break
```

循环不等式证明：

- 初始化
- 保持
- 终止

初始化证明：
第一次循环迭代之前，即 j = 1 时循环不变时成立，没有找到目标数字，于是目标下标为 NIL。

保持证明：
对中间某次循环迭代之前，如果目标下标为 NIL ，那么这次循环迭代判断没有退出的话，下次迭代之前目标下标仍为 NIL。（这里的证明存疑）

终止证明：
当得到目标下标后退出，或者循环便利完成后退出，此时得到的结果是整个序列最后的结果。（这里的证明存疑）

### 2.1-4 考虑把两个 n 位二进制整数加起来的问题，这两个整数分别存储在两个 n 元数组 A 和 B 中。这两个整数的和应按二进制形式存储在一个（n+1）元数组 C 中。请给出该问题的形式化描述，并写出伪代码。

**形式化描述（答案存疑）：**
假设数组内 bit 从小到大排序，即 A[n]...A[1]A[0] 是实际的二进制数。

循环较长的数组 A 或 B ，对每次循环迭代 i ，结果 C[i] 由 A[i] + B[i] 获得，并加上获得 C[i-1] 时的进位。

任意一次循环迭代时，之前的结果已经确定。到循环退出时，全部结果就能确定了。

**伪代码：**

```
maxLen = A.lenght
if B.length > maxLen
  maxLen = B.length

carry = 0
for i = 1 to MaxLen
  C[i] = A[i] + B[i] + carry
  if C[i] > 1
    carry = 1
    C[i] = 0
  else
    carry = 0

if carry == 1
  C[i+1] = 1

```
