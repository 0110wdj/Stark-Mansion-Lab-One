## 2.3 practice

### 2.3-1 使用图 2-4 作为模型，说明归并排序在数组 A=<3,41,52,26,38,57,9,49> 上的操作。

先分解：

```
1   3,41,52,26,38,57,9,49
2   3,41,52,26|38,57,9,49
3   3,41|52,26|38,57|9,49
4   3|41|52|26|38|57|9|49
```

再解决与合并：

```
1   3|41|52|26|38|57|9|49
2   3,41|26,52|38,57|9,49
3   3,26,41,52|9,38,49,57
4   3,9,26,38,41,49,52,57
```

### 2.3-2 重写过程 MERGE，使之不使用哨兵，而是一旦数组 L 或 R 的所有元素均被复制回 A 就立刻停止，然后把另一个数组的剩余部分复制回 A。

MERGE(A, p, q, r) 伪代码：

```
n1 = q - p + 1
n2 = r - q

for i = 1 to n1
  L[i] = A[p + i - 1]
for j = 1 to n2
  R[j] = A[q + j]
i = 1
j = 1

for k = p to r

  if i == n1
    for k to r
      A[k] = R[j]
      j = j + 1
      k = k + 1
    break

  if j == n2
    for k to r
      A[k] = R[i]
      i = i + 1
      k = k + 1
    break

  if L[i] <= R[j]
    A[k] = L[i]
    i = i + 1
  else
    A[k] = R[j]
    i = j + 1

```

### 2.3-3 使用数学归纳法证明：当 n 刚好是 2 的幂时，以下递归式的解是 T(n) = nlgn。

- 若 n = 2
  T(n) = 2
- 若 n = 2^k, k>1
  T(n) = 2T(n/2) + n

证明：
第一步（基础情况）:
我们首先证明当 n = 2 时，等式成立。
2lg2 = 2，基础情况成立。

第二步(归纳假设):
假设对于某个 2 的幂 n = k，存在对应的指数 t = 2^k, 使得 2T(t/2) + t = tlgt 成立，即我们假设命题在 k 上成立。

第三步(归纳证明):
我们需要证明当 n = k + 1 时，存在对应指数 m = 2^n = 2^(k+1), 2T(m/2) + m = mlgm 命题也成立。

即需要证明：
2T(2^(k+1)/2) + 2^(k+1) = 2^(k+1)lg(2^(k+1))
2T(2^k) + 2^(k+1) = 2^(k+1)lg(2^(k+1))
T(2^k) + 2^k = 2^klg(2^(k+1))
T(t) + t = tlg(2t)
T(t) + t = t(1 + lgt)
T(t) = tlgt
令 t = x/2
T(x/2) = (x/2)lg(x/2)
2T(x/2) = xlg(x/2)
2T(x/2) = x(lgx - 1)
2T(x/2) = xlgx - x
2T(x/2) + x = xlgx

根据数学归纳法的证明，基础情况成立，并且假设 n = k 时成立推导出 n = k + 1 时也成立，因此对于所有的正整数 n，命题都成立。

(方程转化有点迷...)

### 2.3-4 我们可以把插人排序表示为如下的一个递归过程。为了排序 A[1..n]，我们递归地排序 A[1..n-1]，然后把 A[n]插人已排序的数组 A［1..n-1］。为插人排序的这个递归版本的最坏情况运行时间写一个递归式。

最坏情况只有一种情况，即初始 A 为有序排列，所求排序为相反排序。

此时，每次插入都是需要遍历全部的子序列元素。

- 若 n == 1
  A[1..1] = A[1..1]
- 若 n > 1
  A[1..n] = A[n] + A[1..n-1]

### 2.3-5 回顾查找问题（参见练习 2.1-3），注意到，如果序列 A 已排好序，就可以将该序列的中点与 v 进行比较。根据比较的结果，原序列中有一半就可以不用再做进一步的考虑了。二分查找算法重复这个过程，每次都将序列剩余部分的规模减半。为二分查找写出迭代或递归的伪代码。证明：二分查找的最坏情况运行时间为 Θ(lgn)。

伪代码：其中 l 和 r 为当前查找的范围下标。

BisectionMethod(A,l,r,v)

```
if l >= r
  if A[r] == v
    return r
  else
    return NIL

n = floor((l+r)/2)
if A[n] == v
  return n
elseif A[n] >= v
  r = n
  return BisectionMethod(A,l,r,v)
else
  l = n
  return BisectionMethod(A,l,r,v)
```

最坏情况：
1、中间一直找不到目标元素，一直到最后一个元素时，才找到目标元素。
2、目标元素不存在。

证明：
显然，最坏情况时，对 2^k 个元素，需要进行 k 次二分查找。

令 n = 2^k
对 n 个元素，需要进行 lg(2^k) = lgn 次二分查找。

对处于 2^(n-1) 到 2^n 之间元素个数的序列来说，视同为 2^n 个元素的序列需要的查找次数。

综上，时间复杂度为 Θ(lgn)。

### 2.3-6 注意到 2.1 节中的过程 INSERTION-SORT 的第 5~7 行的 while 循环采用一种线性查找来(反向)扫描已排好序的子数组 A[1..j-1]。我们可以使用二分查找(参见练习 2.3-5)来把插入排序的最坏情况总运行时间改进到 Θ(nlgn) 吗？

可以。

证明：
对最后一步的插入排序，进行插入位置查找时，需要进行 lgn 次查找了。

对 n 规模的查找，最后一步之前的查找代码小于 lgn 次查找。

那么总的时间消耗为

lg1 + lg2 + lg4 + ... + lg(n-1) + lgn
= (lg1 + lgn)n/2
= Θ(nlgn)

### 2.3-7 描述一个运行时间为 Θ(nlgn) 的算法，给定 n 个整数的集合 S 和另一个整数 x，该算法能确定 S 中是否存在两个其和刚好为 x 的元素。

方案一：

```
// set to array sort Θ(nlgn)
for i = 1 to S.length
  target = x - i
  // BisectionMethod Θ(lgn)
// Θ(nlgn)
```

方案二：

```
// set to hash Θ(n)
// check Θ(n)
// Θ(n)
```

## think

### 2-1（在归并排序中对小数组采用插入排序）

虽然归并排序的最坏情况运行时间为 Θ(nlgn)，而插入排序的最坏情况运行时间为 Θ(n^2)，但是插入排序中的常量因子可能使得它在 n 较小时，在许多机器上实际运行得更快。因此，在归并排序中当子问题变得足够小时，采用插入排序来使递归的叶变粗是有意义的。考虑对归并排序的一种修改，其中使用插入排序来排序长度为 k 的 n/k 个子表，然后使用标准的合并机制来合并这些子表，这里 k 是一个待定的値。

a. 证明：插人排序最坏情况可以在 Θ(nk) 时间内排序每个长度为 k 的 n/k 个子表。
b. 表明在最坏情况下如何在 Θ(nlg(n/k)) 时间内合并这些子表。
c. 假定修改后的算法的最坏情况运行时间为 Θ(nk + nlg(n/k))，要使修改后的算法与标准的归并排序具有相同的运行时间，作为 n 的一个函数，借助 Θ 记号，k 的最大值是什么？
d. 在实践中，我们应该如何选择 k ？

**解：**

- a

证明：
已知，对 n 规模大序列进行插入排序，运行时间为 Θ(lg(n^2))，那么对长度为 k 的子表的运行时间为 Θ(k^2)。
存在 n/k 个这样的子表，那么总的运行时间为 Θ((k^2)(n/k)) = Θ(nk)

- b c

对长度为 k 的子表，如果采用归并排序，运行时间为 Θ(klgk)，那么总的时间消耗为 Θ((klgk)(n/k)) = Θ(nlgk)
从如果该用插入排序，时间消耗为 Θ(nk)。
那么整体的时间消耗变化为 Θ(nlgn) - Θ(nlgk) + Θ(nk) = Θ(nlg(n/k)) + Θ(nk) = Θ(nk + nlg(n/k)

当 Θ(nk) 被忽略时，也就是 k=1/n 时，可以得到最终时间消耗为 Θ(nlg(n/k))。

- d

从整体时间变化来看，应尽量使 Θ(nk) 小于 Θ(nlgk)，即
nk <= nlgk
k <= lgk

从图像的性质可知 y=x 与 y=lgx 无交点，上面不等式无解。

在实践中，还存在被忽略的常量项和和常量系数。上面的不等式可变换为：

c1k + c2 <= c3lgk + c4

根据具体机器来确定 c1~c4，从而确定 k 的最佳取值。

### 2-2（冒泡排序的正确性）

冒泡排序是一种流行但低效的排序算法，它的作用是反复交换相邻的未按次序排列的元素。

BUBBLESORT(A)

```
for i = 1 to A.Length - 1
  for j = A.length downto i + 1
    if A[j] < A[j - 1]
      exchange A[j] with A[j - 1]
```

a. 假设 A' 表示 BUBBLESORT(A) 的输出。为了证明 BUBBLESORT 正确，我们必须证明它将终止并且有：

- A'[1] <= A'[2] <= ... <= A'[n] **(2.3)**

其中 n = A.length。为了证明 BUBBLESORT 确实完成了排序，我们还需要证明什么？

下面两部分将证明不等式（2.3）。

b. 为第 2~4 行的 for 循环精确地说明一个循环不变式，并证明该循环不变式成立。你的证明应该使用本章中给出的循环不变式证明的结构。

c. 使用 (b) 部分证明的循环不变式的终止条件，第 1~4 行的 for 循环说明一个循环不变式，该不变式将使你能证明不等式 (2.3)。你的证明应该使用本章中给出的循环不变式证明的结构。

d. 冒泡排序的最坏情况运行时间是多少？与插入排序的运行时间相比，其性能如何？

**解：**

- a

还需要证明：初始化正确，保持正确。

- b

循环不等式证明：

- 初始化
- 保持
- 终止

初始化证明：
第一次循环迭代之前，即 j = A.length 时循环不变时成立，A[j] 右侧没有比它更小的数字，即没有比它更轻的泡泡。

保持证明：
对中间某次循环迭代 j 之前，A[j] 的右侧没有比它更小的数字，循环迭代之后，A[j-1] 的右侧仍没有比它更小的数字。

终止证明：
当 j = i+1 时结束，第一个元素 A[i+1] 一定是 A[i+1, ..., A.length] 序列中最小的，右侧没有比它更小的数字。

- c

循环不等式证明：

- 初始化
- 保持
- 终止

初始化证明：
第一次循环迭代之前，即 i = 1 时循环不变时成立，A[i] 左侧不存在比它大的数字。

保持证明：
对中间某次循环迭代 i 之前，A[i] 的左侧不存在比它大的数字，循环迭代之后，A[i+1] 的左侧不存在比它大的数字。序列 A[1, ..., i] 总是从小到大排序的。

终止证明：
当 i = A.length - 1 时结束，整个序列都是从小到大排序的。

- d

两层循环都没有中间终止的机制，那么一定都需要全部遍历，无论原始序列 A 是怎样的排序。直接可以给出运行时间 Θ(n^2)。

**性能比较：**

时间复杂度上，插入排序等于冒泡排序。

最好的情况，插入排序和冒泡排序都只有判断语句执行，而没有判断通过后的赋值语句执行。

最坏的情况，或一般情况，需要执行 k 次判断语句通过后的赋值语句。k <= n。

对冒泡排序中的一次冒泡，需要 k 次交换，即 2k 次赋值操作耗时。

对插入排序中的一次插入，需要 k 次移动和 1 次写入操作，即 k+1 次赋值操作耗时。

显然，一般情况下，冒泡排序常量消耗大于插入排序。

（题外话：这里之所以能减少时间的开销，其实是多开销了 1 个元素的空间，用来记录需要插入的数。）

### 2-3（霍纳（Horner）规则的正确性）

给定系数 a0, a1, ..., a(n-1), an 和 x 的值，代码片段

```
y = 0
for i = n downto 0
  y = ai + xy
```

实现了用于求值多项式

P(x) = ∑(k=0->n){(ak)(x^k)} = a0 + x(a1 + x(a2 + ... + x(a(n-1) + xan ... ))

a. 借助 Θ 记号，实现霍纳规则的以上代码片段的运行时间是多少？

b. 编写伪代码来实现朴素的多项式求值算法，该算法从头开始计算多项式的每个项。该算法的运行时间是多少？与霍纳规则相比，其性能如何？

c. 考虑以下循环不变式：

在第 2~3 行 for 循环每次迭代的开始有

y = ∑(k=0->n-(i+1)){a(k+i+1)(x^k)}

把没有项的和式解释为等于 0。遵照本章中给出的循环不变式证明的结构，使用该循环不变式来证明终止时有

y = ∑(k=0->n){(ak)(x^k)}。

d. 最后证明上面给出的代码片段将正确地求由系数 a0, a1, ..., a(n-1), an 刻画的多项式的值。

**解：**

- a

很明显与 n 的规模呈线性相关，运行时间为 Θ(n)

- b

伪代码：

```
sum = 0
for k = 0 to n
  sum = sum + ak(x^k)
```

外层循环，耗时与 n 的规模线性相关。

其中 x^k 的计算与 k 的规模相关，k 每增大 1，计算量都要增加 k+1 次。

k 从 0 到 n，那么总计算量为 n/2。

综上，运行次数为 n(n/2)，运行时间为 Θ(n^2)。

性能差异显而易见。

- c

循环不等式证明：（证明过程存疑）

- 初始化
- 保持
- 终止

初始化证明：
第一次循环迭代之前，即 k = n 时循环不变时成立，y
= ∑(k=0->n-(n+1)){a(k+n+1)(x^k)}
= ∑(k=0->(-1)){a(k+n+1)(x^k)}
= a(0+n+1)(x^0)
= a(n+1)。

保持证明：
对中间某次循环迭代 i 之前，y
= ∑(k=0->n-(i+1)){a(k+i+1)(x^k)}

循环迭代之后，i 变为 i-1，y
= ∑(k=0->n-i){a(k+i)(x^k)}
= ∑(k=0->n-(i+1)){a(k+i+1)(x^k)} + a(i)(x^i)

两者差值 a(i)(x^i) 即第 i 项的数值。每次迭代后，结果的值逐步增加。

终止证明：
当 i = 0 时结束，y
= ∑(k=0->n-1){a(k+1)(x^k)}
= ∑(k=0->n){a(k)(x^k)} + a(-1)(x^(-1))
= ∑(k=0->n){a(k)(x^k)} + 0
= ∑(k=0->n){a(k)(x^k)}

- d

非形式化的说明一下：

当 i 每次变动时，都会在最终结果中加入固定了值的第 i 项结果 a(i)(x^i)

那么循环结束后，就能得到整个多项式的和。
