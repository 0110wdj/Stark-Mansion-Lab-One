## 2.3 practice

### 2.3-1 使用图 2-4 作为模型，说明归并排序在数组 A=<3,41,52,26,38,57,9,49> 上的操作。

先分解：

```
1   3,41,52,26,38,57,9,49
2   3,41,52,26|38,57,9,49
3   3,41|52,26|38,57|9,49
4   3|41|52|26|38|57|9|49
```

再解决与合并：

```
1   3|41|52|26|38|57|9|49
2   3,41|26,52|38,57|9,49
3   3,26,41,52|9,38,49,57
4   3,9,26,38,41,49,52,57
```

### 2.3-2 重写过程 MERGE，使之不使用哨兵，而是一旦数组 L 或 R 的所有元素均被复制回 A 就立刻停止，然后把另一个数组的剩余部分复制回 A。

MERGE(A, p, q, r) 伪代码：

```
n1 = q - p + 1
n2 = r - q

for i = 1 to n1
  L[i] = A[p + i - 1]
for j = 1 to n2
  R[j] = A[q + j]
i = 1
j = 1

for k = p to r

  if i == n1
    for k to r
      A[k] = R[j]
      j = j + 1
      k = k + 1
    break

  if j == n2
    for k to r
      A[k] = R[i]
      i = i + 1
      k = k + 1
    break

  if L[i] <= R[j]
    A[k] = L[i]
    i = i + 1
  else
    A[k] = R[j]
    i = j + 1

```

### 2.3-3 使用数学归纳法证明：当 n 刚好是 2 的幂时，以下递归式的解是 T(n) = nlgn。

- 若 n = 2
  T(n) = 2
- 若 n = 2^k, k>1
  T(n) = 2T(n/2) + n

证明：
第一步（基础情况）:
我们首先证明当 n = 2 时，等式成立。
2lg2 = 2，基础情况成立。

第二步(归纳假设):
假设对于某个 2 的幂 n = k，存在对应的指数 t = 2^k, 使得 2T(t/2) + t = tlgt 成立，即我们假设命题在 k 上成立。

第三步(归纳证明):
我们需要证明当 n = k + 1 时，存在对应指数 m = 2^n = 2^(k+1), 2T(m/2) + m = mlgm 命题也成立。

即需要证明：
2T(2^(k+1)/2) + 2^(k+1) = 2^(k+1)lg(2^(k+1))
2T(2^k) + 2^(k+1) = 2^(k+1)lg(2^(k+1))
T(2^k) + 2^k = 2^klg(2^(k+1))
T(t) + t = tlg(2t)
T(t) + t = t(1 + lgt)
T(t) = tlgt
令 t = x/2
T(x/2) = (x/2)lg(x/2)
2T(x/2) = xlg(x/2)
2T(x/2) = x(lgx - 1)
2T(x/2) = xlgx - x
2T(x/2) + x = xlgx

根据数学归纳法的证明，基础情况成立，并且假设 n = k 时成立推导出 n = k + 1 时也成立，因此对于所有的正整数 n，命题都成立。

(方程转化有点迷...)

### 2.3-4 我们可以把插人排序表示为如下的一个递归过程。为了排序 A[1..n]，我们递归地排序 A[1..n-1]，然后把 A[n]插人已排序的数组 A［1..n-1］。为插人排序的这个递归版本的最坏情况运行时间写一个递归式。

最坏情况只有一种情况，即初始 A 为有序排列，所求排序为相反排序。

此时，每次插入都是需要遍历全部的子序列元素。

- 若 n == 1
  A[1..1] = A[1..1]
- 若 n > 1
  A[1..n] = A[n] + A[1..n-1]

### 2.3-5 回顾查找问题（参见练习 2.1-3），注意到，如果序列 A 已排好序，就可以将该序列的中点与 v 进行比较。根据比较的结果，原序列中有一半就可以不用再做进一步的考虑了。二分查找算法重复这个过程，每次都将序列剩余部分的规模减半。为二分查找写出迭代或递归的伪代码。证明：二分查找的最坏情况运行时间为 Θ(lgn)。

伪代码：其中 l 和 r 为当前查找的范围下标。

BisectionMethod(A,l,r,v)

```
if l >= r
  if A[r] == v
    return r
  else
    return NIL

n = floor((l+r)/2)
if A[n] == v
  return n
elseif A[n] >= v
  r = n
  return BisectionMethod(A,l,r,v)
else
  l = n
  return BisectionMethod(A,l,r,v)
```

最坏情况：
1、中间一直找不到目标元素，一直到最后一个元素时，才找到目标元素。
2、目标元素不存在。

证明：
显然，最坏情况时，对 2^k 个元素，需要进行 k 次二分查找。

令 n = 2^k
对 n 个元素，需要进行 lg(2^k) = lgn 次二分查找。

对处于 2^(n-1) 到 2^n 之间元素个数的序列来说，视同为 2^n 个元素的序列需要的查找次数。

综上，时间复杂度为 Θ(lgn)。
