## 2.3 practice

### 2.3-1 使用图 2-4 作为模型，说明归并排序在数组 A=<3,41,52,26,38,57,9,49> 上的操作。

先分解：

```
1   3,41,52,26,38,57,9,49
2   3,41,52,26|38,57,9,49
3   3,41|52,26|38,57|9,49
4   3|41|52|26|38|57|9|49
```

再解决与合并：

```
1   3|41|52|26|38|57|9|49
2   3,41|26,52|38,57|9,49
3   3,26,41,52|9,38,49,57
4   3,9,26,38,41,49,52,57
```

### 2.3-2 重写过程 MERGE，使之不使用哨兵，而是一旦数组 L 或 R 的所有元素均被复制回 A 就立刻停止，然后把另一个数组的剩余部分复制回 A。

MERGE(A, p, q, r) 伪代码：

```
n1 = q - p + 1
n2 = r - q

for i = 1 to n1
  L[i] = A[p + i - 1]
for j = 1 to n2
  R[j] = A[q + j]
i = 1
j = 1

for k = p to r

  if i == n1
    for k to r
      A[k] = R[j]
      j = j + 1
      k = k + 1
    break

  if j == n2
    for k to r
      A[k] = R[i]
      i = i + 1
      k = k + 1
    break

  if L[i] <= R[j]
    A[k] = L[i]
    i = i + 1
  else
    A[k] = R[j]
    i = j + 1

```

### 2.3-3 使用数学归纳法证明：当 n 刚好是 2 的幂时，以下递归式的解是 T(n) = nlgn。

- 若 n = 2
  T(n) = 2
- 若 n = 2^k, k>1
  T(n) = 2T(n/2) + n

证明：
第一步（基础情况）:
我们首先证明当 n = 2 时，等式成立。
2lg2 = 2，基础情况成立。

第二步(归纳假设):
假设对于某个 2 的幂 n = k，存在对应的指数 t = 2^k, 使得 2T(t/2) + t = tlgt 成立，即我们假设命题在 k 上成立。

第三步(归纳证明):
我们需要证明当 n = k + 1 时，存在对应指数 m = 2^n = 2^(k+1), 2T(m/2) + m = mlgm 命题也成立。

即需要证明：
2T(2^(k+1)/2) + 2^(k+1) = 2^(k+1)lg(2^(k+1))
2T(2^k) + 2^(k+1) = 2^(k+1)lg(2^(k+1))
T(2^k) + 2^k = 2^klg(2^(k+1))
T(t) + t = tlg(2t)
T(t) + t = t(1 + lgt)
T(t) = tlgt
令 t = x/2
T(x/2) = (x/2)lg(x/2)
2T(x/2) = xlg(x/2)
2T(x/2) = x(lgx - 1)
2T(x/2) = xlgx - x
2T(x/2) + x = xlgx

根据数学归纳法的证明，基础情况成立，并且假设 n = k 时成立推导出 n = k + 1 时也成立，因此对于所有的正整数 n，命题都成立。

(方程转化有点迷...)

### 2.3-4 我们可以把插人排序表示为如下的一个递归过程。为了排序 A[1..n]，我们递归地排序 A[1..n-1]，然后把 A[n]插人已排序的数组 A［1..n-1］。为插人排序的这个递归版本的最坏情况运行时间写一个递归式。

最坏情况只有一种情况，即初始 A 为有序排列，所求排序为相反排序。

此时，每次插入都是需要遍历全部的子序列元素。

- 若 n == 1
  A[1..1] = A[1..1]
- 若 n > 1
  A[1..n] = A[n] + A[1..n-1]

### 2.3-5 回顾查找问题（参见练习 2.1-3），注意到，如果序列 A 已排好序，就可以将该序列的中点与 v 进行比较。根据比较的结果，原序列中有一半就可以不用再做进一步的考虑了。二分查找算法重复这个过程，每次都将序列剩余部分的规模减半。为二分查找写出迭代或递归的伪代码。证明：二分查找的最坏情况运行时间为 Θ(lgn)。

伪代码：其中 l 和 r 为当前查找的范围下标。

BisectionMethod(A,l,r,v)

```
if l >= r
  if A[r] == v
    return r
  else
    return NIL

n = floor((l+r)/2)
if A[n] == v
  return n
elseif A[n] >= v
  r = n
  return BisectionMethod(A,l,r,v)
else
  l = n
  return BisectionMethod(A,l,r,v)
```

最坏情况：
1、中间一直找不到目标元素，一直到最后一个元素时，才找到目标元素。
2、目标元素不存在。

证明：
显然，最坏情况时，对 2^k 个元素，需要进行 k 次二分查找。

令 n = 2^k
对 n 个元素，需要进行 lg(2^k) = lgn 次二分查找。

对处于 2^(n-1) 到 2^n 之间元素个数的序列来说，视同为 2^n 个元素的序列需要的查找次数。

综上，时间复杂度为 Θ(lgn)。

### 2.3-6 注意到 2.1 节中的过程 INSERTION-SORT 的第 5~7 行的 while 循环采用一种线性查找来(反向)扫描已排好序的子数组 A[1..j-1]。我们可以使用二分查找(参见练习 2.3-5)来把插入排序的最坏情况总运行时间改进到 Θ(nlgn) 吗？

可以。

证明：
对最后一步的插入排序，进行插入位置查找时，需要进行 lgn 次查找了。

对 n 规模的查找，最后一步之前的查找代码小于 lgn 次查找。

那么总的时间消耗为

lg1 + lg2 + lg4 + ... + lg(n-1) + lgn
= (lg1 + lgn)n/2
= Θ(nlgn)

### 2.3-7 描述一个运行时间为 Θ(nlgn) 的算法，给定 n 个整数的集合 S 和另一个整数 x，该算法能确定 S 中是否存在两个其和刚好为 x 的元素。

方案一：

```
// set to array sort Θ(nlgn)
for i = 1 to S.length
  target = x - i
  // BisectionMethod Θ(lgn)
// Θ(nlgn)
```

方案二：

```
// set to hash Θ(n)
// check Θ(n)
// Θ(n)
```

## think

### 2-1（在归并排序中对小数组采用插入排序）

虽然归并排序的最坏情况运行时间为 Θ(nlgn)，而插入排序的最坏情况运行时间为 Θ(lg(n)^2)，但是插入排序中的常量因子可能使得它在 n 较小时，在许多机器上实际运行得更快。因此，在归并排序中当子问题变得足够小时，采用插入排序来使递归的叶变粗是有意义的。考虑对归并排序的一种修改，其中使用插入排序来排序长度为 k 的 n/k 个子表，然后使用标准的合并机制来合并这些子表，这里 k 是一个待定的値。

a. 证明：插人排序最坏情况可以在 Θ(nk) 时间内排序每个长度为 k 的 n/k 个子表。
b. 表明在最坏情况下如何在 Θ(nlg(n/k)) 时间内合并这些子表。
c. 假定修改后的算法的最坏情况运行时间为 Θ(nk + nlg(n/k))，要使修改后的算法与标准的归并排序具有相同的运行时间，作为 n 的一个函数，借助 Θ 记号，k 的最大值是什么？
d. 在实践中，我们应该如何选择 k ？
