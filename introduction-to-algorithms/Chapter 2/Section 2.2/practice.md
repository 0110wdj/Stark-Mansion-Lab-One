## 2.2 practice

### 2.2-1 用 Θ 记号表示函数 n^3/1000 — 100n^2 — 100n + 3

Θ 不关心常量系数，不关心低阶变量，于是结果为：Θ(n^3)

### 2.2-2 考虑排序存储在数组 A 中的 n 个数：首先找出 A 中的最小元素并将其与 A[1] 中的元素进行交换。接着，找出 A 中的次最小元素并将其与 A[2] 中的元素进行交换。对 A 中前 n-1 个元素按该方式继续。该算法称为选择算法，写出其伪代码。该算法维持的循环不变式是什么？为什么它只需要对前 n-1 个元素，而不是对所有 n 个元素运行？用 Θ 记号给出选择排序的最好情况与最坏情况运行时间。

1、伪代码：

```
for i = 2 to A.length - 1
  minIndex = j
  for j = i to A.length -1
    if A[minIndex] > A[j]
      minIndex = j
  temp = A[i]
  A[i] = A[minIndex]
  A[minIndex] = temp
```

2、循环不变式为：A[1, ... ,i] 总是由小到大的顺序。

3、不用判断到第 n 项，原因：

当判断到第 n-1 项时，只有 n-1 项和第 n 项需要比较。

无论比较结果大小如何，经过可能的交换之后，总是使得第 n-1 项小于等于 第 n 项。

此时整个序列都有序了，判断结束。

4、结果为 Θ(n^2)，无论怎样的输入情况，上面伪代码总是需要执行与 n 规模相关的两次循环。

### 2.2-3 再次考虑线性查找问题(参见练习 2.1-3)。假定要查找的元素等可能地为数组中的任意元素，平均需要检查输入序列的多少元素？最坏情况又如何呢？用 Θ 记号给出线性查找的平均情况和最坏情况运行时间。证明你的答案。

1、平均需要检查 n/2 个元素。

可以想象到，由于分布概率相同，大量目标元素是关于中点对称的。

平均情况就是 n 次检索目标所经过的元素总数的 n 等分。

由于 n 个目标元素均匀的在中间点的两边分布，有 n/2 个元素和另 n/2 个元素对称，对称元素到零点到长度和总是为 n，于是算法经过的元素总数为 n(n/2)。

平均需要检查 n(n/2)/n = n/2 个元素。

2、最坏情况是，目标元素总是在最末尾位置，总是需要检查 n 个元素。

3、Θ 不关心常量系数，于是结果都是 Θ(n)。

### 2.2-4 应如何修改任何一个算法，才能使之具有良好的最好情况运行时间？

方法 1：
针对输入情况的分布概率，重点优化高概率出现的输入情况对应的算法片段。

方法 2：
算法执行前，对输入内容进行预处理，使其更符合算法的预设情景。
